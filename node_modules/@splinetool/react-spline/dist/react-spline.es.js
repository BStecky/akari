var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import require$$0, { forwardRef, useRef, useState, useEffect } from "react";
import { Application } from "@splinetool/runtime";
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = require$$0, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h = null;
  g !== void 0 && (e = "" + g);
  a.key !== void 0 && (e = "" + a.key);
  a.ref !== void 0 && (h = a.ref);
  for (b in a)
    m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      d[b] === void 0 && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const Spline = forwardRef(({
  scene,
  id,
  style,
  className,
  onMouseDown,
  onMouseUp,
  onMouseHover,
  onKeyDown,
  onKeyUp,
  onStart,
  onLookAt,
  onFollow,
  onWheel,
  onLoad,
  autoRender = false
}, ref) => {
  const canvasRef = useRef(null);
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() => {
    setIsLoading(true);
    let speApp;
    const events = [{
      name: "mouseDown",
      cb: onMouseDown
    }, {
      name: "mouseUp",
      cb: onMouseUp
    }, {
      name: "mouseHover",
      cb: onMouseHover
    }, {
      name: "keyDown",
      cb: onKeyDown
    }, {
      name: "keyUp",
      cb: onKeyUp
    }, {
      name: "start",
      cb: onStart
    }, {
      name: "lookAt",
      cb: onLookAt
    }, {
      name: "follow",
      cb: onFollow
    }, {
      name: "scroll",
      cb: onWheel
    }];
    if (canvasRef.current) {
      speApp = new Application(canvasRef.current, {
        autoRender
      });
      async function init() {
        await speApp.load(scene);
        for (let event of events) {
          if (event.cb) {
            speApp.addEventListener(event.name, event.cb);
          }
        }
        setIsLoading(false);
        onLoad == null ? void 0 : onLoad(speApp);
      }
      init();
    }
    return () => {
      for (let event of events) {
        if (event.cb) {
          speApp.removeEventListener(event.name, event.cb);
        }
      }
      speApp.dispose();
    };
  }, [scene]);
  return /* @__PURE__ */ jsx("div", {
    style: __spreadValues({
      display: `${isLoading ? "none" : "flex"}`
    }, style),
    className,
    ref,
    children: /* @__PURE__ */ jsx("canvas", {
      ref: canvasRef,
      id
    })
  });
});
export { Spline as default };
